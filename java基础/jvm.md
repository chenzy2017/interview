#jvm
1. 线上频繁fullgc,怎么处理?
    - 特征:
        1. 线上多个线程的 CPU 都超过了 *** jstack 命令可以看到这些线程主要是垃圾回收线程。
        2. 通过 jstat 命令监控 GC 情况，可以看到 Full GC 次数非常多，并且次数在不断增加。
    - 排查步骤:
        1. 找到cpu占用过高的进程(top)
        2. 找到进程下占用过高的线程(top -Hp 进程id )
        3. jstack查找nid=线程id, 是否由于gc频繁导致的(日志有VM Thread代表垃圾回收)
        4. 可以查看 GC 的情况(jstat -gcutil 进程id 1000 10), 如果gc频繁,基本确定是由于内存溢出导致的;
        5. Dump出内存日志(jmap dump:format=b,file= ), 用mat工具查看是哪个对象比较消耗内存,
           如果日志里面没有哪个对象耗内存, 再查看下是不是由于手动调用system.gc(),
           如果是, 可以添加-XX:+DisableExplicitGC来禁用JVM 对显示 GC 的响应;
2. 分析cpu过高
    1. 查看该进程中有哪些线程 CPU 过高(top -Hp)
       这样我们就能得到 CPU 消耗比较高的线程 id。
    2. 接着通过该线程 id 的十六进制表示在 jstack 日志中查看当前线程具体的堆栈信息。
       在这里我们就可以区分导致 CPU 过高的原因具体是 Full GC 次数过多还是代码中有比较耗时的计算了。
    3. 如果是 Full GC 次数过多，那么通过 jstack 得到的线程信息会是类似于 VM Thread 之类的线程
       而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。
3. 分析接口偶发性耗时长,并给出解决方案
    1. 先用jmeter压测;
    2. 找到卡住的那些线程, dump堆栈日志, 在日志中找打印出 TIMED_WAITING 相同日志的地方
4. 如何分析耗时sql,怎么解决
    1. 首先分析索引失效;
    2. 用where字句替换HAVING字句(HAVING只会在检索出所有记录之后才对结果集进行过滤)
    3. 用varchar代替char
    4. update只更新要更新的字段, 不要全部字段
    5. limit m,n要慎重(越往后面翻页即m越大的情况下SQL的耗时会越来越长)---正确做法是:先取出主键id，然后通过主键id跟原表进行Join关联查询