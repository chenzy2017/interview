# mysql
1. 索引失效-----Extra中没有出现using index
    1. 违反最左前缀法则(口号：带头大哥不能死、中间兄弟不能断)
    2. 在索引列上做任何操作(计算、函数)
    3. 索引范围条件右边的列(> < between)
    4. 尽量使用覆盖索引(少用select *, 能减少回表,减少树的搜索次数)--回表是指在非主键索引树上查询, 拿到id再回到主键索引树上查询
    5. 使用不等于（!=、<>, NOT IN不行）
    6. like以通配符开头（'%abc'）
    7. varchar不加单引号索引失效
    8. or连接(用它来连接时索引会失效)
    9. order by(后面既有desc,又有asc;  后面两个字段不遵循最左前缀法则;  含非索引字段)
    10. group by一样
2. 如何选择合适的列创建索引  
   3要 3不要
    - 3要:
        1. 频繁作为查询条件的字段应该创建索引
        2. 查询中与其它表关联的字段，外键关系建立索引
        3. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；这样查询可以利用索引的排序，加快排序查询时间；
    - 3不要:
        1. 唯一性很差的字段不合适做索引，如性别(eg:有10条数据, 如果建立了索引, 需要先在非主键索引表中找到6个女生, 再回表扫描6行数据, 性能还不如不用)
        2. 更新频繁的字段不适合，耗时且影响性能
        3. Where条件里用不到的字段不创建索引
3. delete会有什么隐患? 怎么优化
    - 隐患:
        1. 因为delete+where 删除记录数据库空间不减少, 会产生大量碎片，影响磁盘IO；---->解决办法:使用 OPTIMIZE TABLE 整理数据文件的碎片,
           注意，在OPTIMIZE TABLE运行过程中，MySQL会锁定表, 在半夜进行
    - 优化:
        1. where条件用索引
        2. 删除三个月以前的数据正确操作(晚上没有业务场景):
            1. 先创建临时表tmp
            2. 将需要的数据保留到tmp表中,然后通过rename将当前业务表替换为bak表,再将tmp表替换为业务表, 最后删除bak表;
        3. 每隔一段时间执行一次 OPTIMIZE TABLE
4. 事务隔离级别  
   事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性
    1. 读未提交（READ UNCOMMITTED）
    2. 读提交 （READ COMMITTED）
    3. 可重复读 （REPEATABLE READ）
    4. 串行化 （SERIALIZABLE）
5. 事务和数据库锁的关系?
    1. MyISAM引擎:表级锁;  innoDB:行级锁，它也支持表级锁;
    2. 读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。
        - 快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁
        - 当前读，读取的是记录的最新版本，并且，当前读返回的记录前，都会加上锁，保证其他事务不会再并发修改这条记录
    3. 锁类型
        - 共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。
        - 排他锁(X锁):假设事务T1对数据A加上共享锁，那么事务T2不能读数据A，不能修改数据A。  
          我们通过update、delete等语句加上的锁都是行级别的锁。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。
    4. 当执行select 的时候 默认是不加锁的 （快照读） （这种说法在隔离级别为Serializable中不成立）  
       如果想要对某个行数据加锁需要 执行如下：  
       select * from table where num = 200 lock in share mode 共享锁  
       select * from table where num = 200 for update 行级锁  
       这是通过显示加锁实现的,当执行update,insert,delete的时候 默认是加行锁的

