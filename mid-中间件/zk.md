# zk
1. 描述zookeeper集群架构?
    1. zookeeper集群是一主多从的模型，节点分成三种角色：leader、follower和observer。leader负责写、follower和observer负责读
    2. 采用tcp协议确保消息的顺序性,zab作为其数据一致性的核心算法
2. zk的leader挂掉了怎么办（单点故障）
    1. zk采用zab协议(Zookeeper Atomic Broadcast)进行选举, zab协议特点:
        - follower节点上所有的写请求都转发给leader;
        - 写操作严格有序;
        - ZooKeeper使用自定义的两阶段提交协议来保证各个节点的事务一致性;(改编后:只需要超过半数的参与者回复yes)  
          总结: ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。
          ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。
    2. zookeeper集群的状态分为两种：正常状态和异常状态。也就是有leader（能提供服务）和没有leader（进入选举）
        - 广播模式:就是指zookeeper正常工作的模式
            1. leader从客户端或者follower那里收到一个写请求
            2. leader生成一个新的事务并为这个事务生成一个唯一的Zxid，
            3. leader将这个事务发送给所有的follows节点
            4. follower节点将收到的事务请求加入到历史队列(history queue)中，并发送ack给leader
            5. 当leader收到大多数follower（超过半数数量）的ack消息，leader会发送commit请求
            6. 当follower收到commit请求时，会判断该事务的Zxid是不是比历史队列中的任何事务的Zxid都小，如果是则commit，如果不是则等待比它更小的事务的commit
        - 恢复模式:当leader故障之后，zookeeper集群进入无主模式,此时zookeeper集群不能对外提供服务，必须选出一个新的leader完成数据一致后才能重新对外提供服务。
            1. zookeeper官方宣称	集群可以在200毫秒内选出一个新leader;
            2. 正常模式下的几个步骤，每个步骤都有可能因为leader故障而中断。但是恢复过程只与leader有没有commit有关;首先看前三个步骤，只做了一件事，把事务发送出去。
            3. 如果事务没有发出去，所有follower都没有收到这个事务，leader故障了。所有的follower都不知道这个事务的存在，根据心跳检测机制，follower发现leader故障，重新选出一个leader。会根据每个节点Zxid来选择，谁的Zxid最大，表示谁的数据最新，自然会被选举成新的leader。如果Zxid都一样，表示在follower故障之前，所有的follower节点数据完全一致，此时选择myid最大的节点成为新的leader，因为有一个固定的选举标准会加快选举流程。新的leader选出来之后，所有节点的数据本身就是一致的，此时就可以对外提供服务。
               假设新的leader选出来之后，原来的leader又恢复了，此时原来的leader会自动成为follower，之前的事务即使重新发送给新的leader，因为新的leader已经开启了新的纪元，而原先的leader中Zxid还是旧的纪元，自然会被丢弃。并且该节点的Zxid也会更新成新的纪元。
               纪元的意思就是标识当前leader是第几任leader，相当于改朝换代时候的年号。
               如果在leader故障之前已经commit，zookeeper依然会根据Zxid或者myid选出数据最新的那个follower作为新的leader。新leader与follower建立FIFO的队列， 先将自身有而follower缺失的事务发送给它，再将这些事务的commit命令发送给 follower，这便保证了所有的follower都保存了所有的事务、所有的follower都处理了所有的消息。
            4. 如果在leader故障之前已经commit，zookeeper依然会根据Zxid或者myid选出数据最新的那个follower作为新的leader。新leader与follower建立FIFO的队列， 先将自身有而follower缺失的事务发送给它，再将这些事务的commit命令发送给 follower，这便保证了所有的follower都保存了所有的事务、所有的follower都处理了所有的消息。
3. 两阶段提交是用来解决分布式事务的,操作步骤?
    1. 协调者询问所有的参与者是不是可以提交了
    2. 参与者回复yes or no
    3. 协调者收到所有的yes之后执行commit否则执行rollback
    4. 参与者执行完成后回复ACK
4. 有了解过Paxos算法吗?[ˈpæksoʊs]
    1. (无敌)Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。
    2. 三种角色Proposer,Acceptor,Learners
    3. zab是paxos的一种简化版本
5. zk所以没有采用Paxos是因为Paxos保证不了业务逻辑顺序(eg:a导致了b,但是消息一起发送的,需要确保a必须在b之前执行)
6. TCP具体是通过怎样的方式来保证数据的顺序化传输呢？
    1. 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，
    2. 如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。
    3. 接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，
    4. 接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。
7. 你们系统是怎么实现分布式事务
    1. 2PC----XA两阶段提交(不可取);
        1. XA 它包含两个部分：事务管理器和本地资源管理器;
        2. 是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险;
           所以不适合解决微服务事务问题
        3. 问题其实就出在每个参与者自身的状态只有自己和协调者知道，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。
    2. 3pc----三阶段提交;
       相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。
       3PC 包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段
       总结:3PC 相对于 2PC,做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，
       但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。因此一般都需要有定时扫描补偿机制
    3. TCC---基于业务的分布式事务;
       难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应Try - Confirm - Cancel
       因此 TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作。
       TCC可以跨数据库、跨不同的业务系统来实现事务
    4. 本地消息表---最终一致性，容忍了数据暂时不一致的情况
       将业务的执行和将消息放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中业务肯定是执行成功的。
       然后再去调用下一个操作，如果下一个操作调用成功了, 消息表的消息状态直接改成已成功。
       如果调用失败，写一个后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。
    5. RocketMQ的消息事务
       第一步先给 Broker 发送事务消息即半消息，半消息不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。
       再根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。
       并且 RocketMQ 的发送方会提供一个反查事务状态接口，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。
       如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。
       如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。
    6. 使用阿里的开源框架seata












